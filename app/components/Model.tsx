/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect, forwardRef, RefObject } from 'react'
import { useGLTF, useAnimations, Edges } from '@react-three/drei'
import { Group, Mesh, MeshStandardMaterial, Vector3 } from 'three'
import { useFrame } from '@react-three/fiber'

interface ModelProps {
  position?: [number, number, number]
  scale?: [number, number, number]
  rotation?: [number, number, number]
  isAnimated?: boolean
  onConnectionPointsUpdate?: (points: Vector3[]) => void
}

export const Model = forwardRef<Group, ModelProps>(({ isAnimated = true, onConnectionPointsUpdate, ...props }, ref) => {
  const group = useRef<Group>(null)
  const meshRef = useRef<Mesh>(null)
  const lastUpdateTime = useRef(0)
  
  // Références aux mesh de connexion
  const connection1Ref = useRef<Mesh>(null)
  const connection2Ref = useRef<Mesh>(null)
  const connection3Ref = useRef<Mesh>(null)
  const connection4Ref = useRef<Mesh>(null)
  const connection1001Ref = useRef<Mesh>(null)
  
  const { nodes, animations } = useGLTF('/dna-draco.glb')
  const { actions } = useAnimations(animations, ref as RefObject<Group> || group)

  // Créer un matériau chrome wireframe
  const chromeMaterial = new MeshStandardMaterial({
    color: '#ffffff',
    metalness: 1.0,
    roughness: 0.0,
    envMapIntensity: 2.0,
    emissive: '#000000',
    emissiveIntensity: 0.0,
    transparent: true,
    opacity: 0.05, // Encore plus transparent pour un effet wireframe pur
    wireframe: false, // On garde le mesh mais très transparent
  })

  useEffect(() => {
    // Jouer l'animation de base du modèle si elle existe et si isAnimated est true
    if (actions && Object.keys(actions).length > 0) {
      const firstAction = Object.values(actions)[0]
      if (firstAction) {
        if (isAnimated) {
          // Si l'animation n'est pas déjà en cours, la démarrer
          if (!firstAction.isRunning()) {
            firstAction.play()
            firstAction.setLoop(2201, Infinity) // Boucle infinie (2201 = LoopRepeat)
            firstAction.timeScale = 0.5 // Vitesse à 0.5x (plus lent)
          } else {
            // Si elle est déjà en cours, la reprendre
            firstAction.paused = false
          }
        } else {
          // Mettre en pause au lieu d'arrêter
          firstAction.paused = true
        }
      }
    }
    
    // Envoyer les points de connexion une fois que le modèle est chargé
    if (onConnectionPointsUpdate) {
      const connectionRefs = [connection1Ref, connection2Ref, connection3Ref, connection4Ref, connection1001Ref];
      const connectionPositions = connectionRefs
        .filter(ref => ref.current)
        .map(ref => {
          const worldPos = new Vector3();
          ref.current!.getWorldPosition(worldPos);
          return worldPos;
        });
      
      if (connectionPositions.length > 0) {
        onConnectionPointsUpdate(connectionPositions);
      }
    }
  }, [actions, isAnimated, onConnectionPointsUpdate])

  useFrame((state) => {
    // Animation du matériau chrome
    if (chromeMaterial && isAnimated) {
      // Variation subtile de l'intensité de l'environnement
      chromeMaterial.envMapIntensity = 2.0 + Math.sin(state.clock.elapsedTime * 0.5) * 0.3
    }
    
    // Mettre à jour les positions des points de connexion avec les transformations du modèle
    // Throttle les mises à jour pour éviter les boucles infinies (max 30fps)
    if (onConnectionPointsUpdate && state.clock.elapsedTime - lastUpdateTime.current > 0.033) {
      const connectionRefs = [connection1Ref, connection2Ref, connection3Ref, connection4Ref, connection1001Ref];
      const connectionPositions = connectionRefs
        .filter(ref => ref.current)
        .map(ref => {
          const worldPos = new Vector3();
          ref.current!.getWorldPosition(worldPos);
          return worldPos;
        });
      
      if (connectionPositions.length > 0) {
        lastUpdateTime.current = state.clock.elapsedTime;
        onConnectionPointsUpdate(connectionPositions);
      }
    }
  })

  return (
    <group ref={ref || group} {...props} dispose={null}>
      <group name="Scene">
        <mesh
          ref={meshRef}
          name="DNA_logo_3d"
          castShadow
          receiveShadow
          geometry={(nodes.DNA_logo_3d as Mesh).geometry}
          material={chromeMaterial}
          rotation={[Math.PI / 2, 0, 0]}
        >
          <Edges
            geometry={(nodes.DNA_logo_3d as Mesh).geometry}
            scale={1.002} // Légèrement plus grand pour éviter le z-fighting
          />
        </mesh>
        
        {/* Sphères de connexion intégrées au modèle */}
        <mesh
          ref={connection1Ref}
          name="connection1"
          castShadow
          receiveShadow
          geometry={(nodes.connection1 as Mesh).geometry}
          material={chromeMaterial}
          position={[-1.192, 2.221, -5.846]}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={0.034}
        />
        <mesh
          ref={connection2Ref}
          name="connection2"
          castShadow
          receiveShadow
          geometry={(nodes.connection2 as Mesh).geometry}
          material={chromeMaterial}
          position={[1.011, -2.325, -5.773]}
          rotation={[-Math.PI / 2, -0.202, 0]}
          scale={0.034}
        />
        <mesh
          ref={connection3Ref}
          name="connection3"
          castShadow
          receiveShadow
          geometry={(nodes.connection3 as Mesh).geometry}
          material={chromeMaterial}
          position={[-1.809, 1.597, -4.224]}
          rotation={[-Math.PI / 2, -0.505, 0]}
          scale={0.034}
        />
        <mesh
          ref={connection4Ref}
          name="connection4"
          castShadow
          receiveShadow
          geometry={(nodes.connection4 as Mesh).geometry}
          material={chromeMaterial}
          position={[-0.443, 2.478, -7.483]}
          rotation={[-Math.PI / 2, -0.505, 0]}
          scale={0.038}
        />
        <mesh
          ref={connection1001Ref}
          name="connection1001"
          castShadow
          receiveShadow
          geometry={(nodes.connection1001 as Mesh).geometry}
          material={chromeMaterial}
          position={[1.752, 11.888, 1.861]}
          scale={0.034}
        />
      </group>
    </group>
  )
})

Model.displayName = 'Model'

useGLTF.preload('/dna-draco.glb')
